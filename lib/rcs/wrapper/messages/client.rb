# frozen_string_literal: true

require_relative "../../messages/client"
require_relative "../../types/message_event"
require "json"
require "faraday"

module Pinnacle
  # Interface/contract for request objects compatible with webhook processing.
  # Request objects must respond to methods for accessing headers and body.
  module RequestLike
    # @abstract
    # @return [Hash, Object] Headers hash or object that responds to [] or fetch
    def headers
      raise NotImplementedError
    end

    # @abstract
    # @return [Hash, String, StringIO] Body content (parsed hash, JSON string, or IO)
    def body
      raise NotImplementedError
    end
  end

  # @api private
  # Internal helper class to normalize different web framework request objects.
  # Supports Rails (ActionDispatch::Request), Sinatra (Sinatra::Request),
  # Rack (Rack::Request), and custom request objects.
  class RequestWrapper
    attr_reader :original_request

    # @param request [Object] The original request object from the web framework
    def initialize(request)
      @original_request = request
      validate_request!
    end

    # Extract the PINNACLE-SIGNING-SECRET header from the request
    # @return [String, nil] The signing secret header value
    def signing_secret_header
      # Try standard headers method (Rails, Sinatra)
      if @original_request.respond_to?(:headers)
        headers = @original_request.headers
        return headers["PINNACLE-SIGNING-SECRET"] || headers["pinnacle-signing-secret"] if headers
      end

      # Try Rack env
      if @original_request.respond_to?(:env)
        env = @original_request.env
        return env["HTTP_PINNACLE_SIGNING_SECRET"] if env&.key?("HTTP_PINNACLE_SIGNING_SECRET")
        return env["HTTP_PINNACLE-SIGNING-SECRET"] if env&.key?("HTTP_PINNACLE-SIGNING-SECRET")
      end

      # Try direct hash access (testing/mock objects)
      if @original_request.respond_to?(:[])
        return @original_request["PINNACLE-SIGNING-SECRET"] || @original_request["pinnacle-signing-secret"]
      end

      nil
    end

    # Extract and parse the request body
    # @return [Hash] The parsed request body as a hash
    def parsed_body
      # If body is already a hash (Rails params)
      if @original_request.respond_to?(:body) && @original_request.body.is_a?(Hash)
        return @original_request.body
      end

      # If we have request.body that's a StringIO or String
      if @original_request.respond_to?(:body)
        body_content = @original_request.body

        # Handle StringIO
        if body_content.respond_to?(:read)
          body_content.rewind if body_content.respond_to?(:rewind)
          body_str = body_content.read
          body_content.rewind if body_content.respond_to?(:rewind)
          return JSON.parse(body_str) if body_str.is_a?(String) && !body_str.empty?
        end

        # Handle String
        return JSON.parse(body_content) if body_content.is_a?(String) && !body_content.empty?
      end

      # Try request_body method
      if @original_request.respond_to?(:request_body)
        return JSON.parse(@original_request.request_body)
      end

      # Fallback: if request itself is a hash
      return @original_request if @original_request.is_a?(Hash)

      # Last resort
      JSON.parse(@original_request.to_s)
    end

    private

    # Validate that the request object has the minimum required interface
    def validate_request!
      has_headers = @original_request.respond_to?(:headers) ||
                    @original_request.respond_to?(:env) ||
                    @original_request.respond_to?(:[])

      has_body = @original_request.respond_to?(:body) ||
                 @original_request.respond_to?(:request_body) ||
                 @original_request.is_a?(Hash)

      return if has_headers && has_body

      raise ArgumentError, "Request object must respond to headers/env and body methods. " \
                           "Supported: Rails ActionDispatch::Request, Sinatra::Request, Rack::Request, or similar."
    end
  end

  # Note: RequestWrapper is internal - use at your own risk
  # Not using private_constant to allow internal cross-file access

  # Enhanced Messages client with webhook processing capabilities
  # Extends the autogenerated MessagesClient to add webhook processing
  class EnhancedMessagesClient < Pinnacle::MessagesClient
    # Process and validate incoming webhook requests
    #
    # @param req [Object] Request object from any Ruby web framework.
    #   Supported frameworks: Rails (ActionDispatch::Request), Sinatra (Sinatra::Request),
    #   Rack (Rack::Request), or any object that responds to #headers and #body
    # @param secret [String, nil] Optional signing secret. If not provided, will use ENV['PINNACLE_SIGNING_SECRET']
    # @return [Pinnacle::Types::MessageEvent] The validated message event
    # @raise [Faraday::UnauthorizedError] If webhook signature validation fails
    # @raise [ArgumentError] If request object doesn't implement required interface
    # @example Rails controller
    #   class WebhooksController < ApplicationController
    #     def receive
    #       client = Pinnacle::EnhancedMessagesClient.new(request_client: request_client)
    #       message_event = client.process(request)
    #       # Process message_event...
    #     end
    #   end
    #
    # @example Sinatra
    #   post '/webhook' do
    #     client = Pinnacle::EnhancedMessagesClient.new(request_client: request_client)
    #     message_event = client.process(request)
    #     # Process message_event...
    #   end
    #
    # @example With custom secret
    #   message_event = client.process(request, secret: "my_custom_secret")
    def process(req, secret: nil)
      # Wrap the request for normalized access
      request_wrapper = RequestWrapper.new(req)

      # Get signing secret from parameter or environment
      signing_secret = secret || ENV["PINNACLE_SIGNING_SECRET"]

      # Extract header secret and body
      header_secret = request_wrapper.signing_secret_header
      body = request_wrapper.parsed_body

      # Validate signing secret exists
      unless signing_secret
        raise UnauthorizedError.new(
          error: "Make sure to set the PINNACLE_SIGNING_SECRET environment variable or pass the secret as an argument to the process method"
        )
      end

      # Validate header secret exists
      unless header_secret
        raise UnauthorizedError.new(
          error: "Failed to get the PINNACLE-SIGNING-SECRET header from request"
        )
      end

      # Validate signatures match
      unless header_secret == signing_secret
        raise UnauthorizedError.new(error: "Invalid webhook signature")
      end

      # Parse and return MessageEvent
      Pinnacle::Types::MessageEvent.from_json(json_object: body.to_json)
    end
  end

  # Async version of EnhancedMessagesClient
  # Extends the autogenerated AsyncMessagesClient to add webhook processing
  class AsyncEnhancedMessagesClient < Pinnacle::AsyncMessagesClient
    # Process and validate incoming webhook requests asynchronously
    #
    # @param req [Object] Request object from any Ruby web framework
    # @param secret [String, nil] Optional signing secret
    # @return [Pinnacle::Types::MessageEvent] The validated message event wrapped in Async
    # @raise [Faraday::UnauthorizedError] If webhook signature validation fails
    # @raise [ArgumentError] If request object doesn't implement required interface
    def process(req, secret: nil)
      Async do
        request_wrapper = RequestWrapper.new(req)
        signing_secret = secret || ENV["PINNACLE_SIGNING_SECRET"]

        header_secret = request_wrapper.signing_secret_header
        body = request_wrapper.parsed_body

        unless signing_secret
          raise UnauthorizedError.new(
            error: "Make sure to set the PINNACLE_SIGNING_SECRET environment variable or pass the secret as an argument to the process method"
          )
        end

        unless header_secret
          raise UnauthorizedError.new(
            error: "Failed to get the PINNACLE-SIGNING-SECRET header from request"
          )
        end

        unless header_secret == signing_secret
          raise UnauthorizedError.new(error: "Invalid webhook signature")
        end

        Pinnacle::Types::MessageEvent.from_json(json_object: body.to_json)
      end
    end
  end
end
